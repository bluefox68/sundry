# 指定的定义和使用
1.定义：使用模块的directive方法。其第一个参数为指令名，第二个参数为定义指令的函数，其返回值一般为一个配置对象(用来进行配置指令属性）。
# 指令的表现形式:
1.一个新的HTML元素
2.元素的属性
3.CSS class
4.注释
# 指令配置属性
1.restrict：其值有四种，可以相互组合使用。
  <1>A:指令表现为元素的属性
  <2>E:指令表现为一个元素
  <3>C:指令表现为元素的class
  <4>M:注释
2.replace：指明在使用我们定义的指令时，生成的HTML元素是否用来替换掉我们定义的指令(默认生成的html是插入到我们定义的指令中的)。
3.template：即指令编译后的HTML标记。其可以用templateUrl替换。
4.link:用来指定模板如何使用scope。其有三个参数:
  <1>scope:指令的scope。
  <2>elem:包装后的DOM元素。
  <3>attrs:指定所在元素的属性的标准化的参数对象
5.compile:用来做一些DOM改造，需返回一个link函数。另外，其有两个参数：
  <1>tElem:指令所在的元素
  <2>attrs:元素上赋予的参数的标准化列表
6.scope:用来指定创建的模板的作用域是否独立。其有三个值。
  <1>false:默认值。指令模板直接使用父scope,并没有新建scope.
  <2>true:指令模板使用一个继承自父scope的新的子scope，即其新建了scope。
  <3>{}:指令模板使用一个独立的和父scope隔离的scope.避免对父scope污染(因为scope不是该值的话，创建的scope可以访问父的scope,即可以对父的scope进行随意改写)，其也是新建了一个scope。

  注：使用隔离的scope并不意味着我们完全不能访问父scope的属性，angular也提供了一种通过向scope的{}中传入特殊前缀标识符的方法使我们可以访问父scope属性。具体的标识符如下:
  i.@:用来进行单项绑定的前缀标识符。
  ii.=:用来进行双向数据绑定前缀标识符。
  iii.&:用来绑定函数方法的前缀标识符。
  其定义和使用如下：

  scope:{
    name:"@myName",
    age :"=myAge",
    changeAge:"&changeMyAge"
  }

  <div my-directive my-name="{{name}}" my-age="age" change-my-age="changeMyAge()"></div>


# 指令被编译的机理
当应用引导启动的时候，angularJS开始使用$compile服务遍历DOM元素。$compile服务会去模板中搜索注册过的指令，然后执行他们的compile方法。它们的compile方法会返回一个link函数，其会被添加到一个link函数列表中。待所有搜索到的指令的compile执行完成，则开始一一执行link函数列表里面的函数，最后指令创造出来的模板即被在正确的scope下解析和处理，返回具有事件响应的真实的DOM节点。
